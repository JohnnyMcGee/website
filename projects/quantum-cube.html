<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Cube - Cloud-based Speed Cube Timer App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="stylesheet" href="/assets/project.css">
</head>

<body>
    <header class="header">
        <a href="/">
            <div class="header_logo">
                <img src="/assets/images/jmd-logo-glitch-transparent.png" alt="JohnnyMcGee.dev Logo" />
            </div>
        </a>
        <button id="menu-button">
            <div class="hamburger">
                <div class="hamburger_bar hamburger_bar--top"></div>
                <div class="hamburger_bar hamburger_bar--middle"></div>
                <div class="hamburger_bar hamburger_bar--bottom"></div>
            </div>
        </button>
    </header>
    <div id="menu-drawer" class="drawer">
        <nav class="menu">
            <ul class="menu_link-list">
                <li>
                    <a class="nav-link" href="/projects/quantum-cube.html">Quantum Cube</a>
                </li>
                <li>
                    <a class="nav-link" href="/projects/earth-breeze.html">Earth Breeze</a>
                </li>
                <li>
                    <a class="nav-link" href="/projects/psychobummer.html">PsychoBummer</a>
                </li>
            </ul>
        </nav>
    </div>
    <section class="hero-section">
        <h1 class="uppercase animate-in color-primary">QUANTUM CUBE</h1>
        <h6 class="uppercase animate-in">Cloud-based Speed Cubing Timer App</h6>
    </section>
    <main class="main-content">
        <section class="project-description">
            <article>
                <p>
                    Quantum Cube is a timer app for speed cubers. Users create sessions and record their solve times,
                    and track their statistics over time. The solves are stored in the cloud and are accessible
                    on Quantum Cube's Android, iOS, and web apps. The simple, elegant design gets out of the user's way,
                    so they can test their skills and prepare for competitions.
                </p>
                <div class="project-attributes">
                    <table border="1" frame="hsides" rules="rows">
                        <tr>
                            <th>Backend</th>
                            <td>Node.js, Express, Redis, PostgreSQL</td>
                        </tr>
                        <tr>
                            <th>
                                Web Frontend
                            </th>
                            <td>
                                React, Redux, Sass
                            </td>
                        </tr>
                        <tr>
                            <th>
                                Mobile Frontend
                            </th>
                            <td>
                                Flutter, Bloc, Isar DB
                            </td>
                        </tr>
                        <tr>
                            <th>
                                Puzzles Supported
                            </th>
                            <td>
                                2x2x2, 3x3x3, 4x4x4, 5x5x5, 6x6x6, 7x7x7, Pyraminx, Megaminx, Skewb, Square-1, Clock
                            </td>
                            1,811,707

                        </tr>
                        <tr>
                            <th>Solves Stored in the Cloud</th>
                            <td>Over 1.8 Million</td>
                        </tr>
                    </table>
                </div>

                <h2>Features</h2>
                <h4>Cloud Storage for Solve Times</h4>
                <p>
                    Quantum Cube's source of truth is a cloud-hosted PostgreSQL database.
                    It uses Redis for server-side session storage and lightweight caching.
                    An Express.js JSON API provides a consistent interface for both web and mobile clients.
                </p>
                <h4>React Single-Page Application</h4>
                <p>
                    On the web, QC's React SPA provides a smooth, responsive user experience.
                    Cubing sessions can be long or short, with solve data and statistics updating continuously in real
                    time.
                    A redux store serves nicely to manage application state and keep the UI in sync with the
                    backend.
                </p>
                <h4>Flutter Mobile App</h4>
                <p>
                    Quantum Cube makes solve data avilable on any device, anywhere in the world.
                    With the Flutter framework, a single codebase compiles to native code for nearly any device or
                    platform.
                    The mobile app also supports offline mode, so cubers can take their solves on the go.
                    The Flutter Bloc state management library and Isar local database help to make data access appear
                    nearly instantaneous.
                </p>

                <h2>Engineering Challenges</h2>
                <h3>Offline mode -- a distributed data problem</h3>
                <h4>The Challenge:</h4>
                <p>Imagine beating your personal best time, only to find out that your phone is offline and the solve
                    data is lost. Unacceptable! Quantum Cube anticipates that users may have limited or no internet
                    access. How can an app tolerate unreliable in networks while preserving data integrity?</p>
                <h4>The Solution:</h4>
                <p>
                    To ensure data integrity and availability, Quantum Cube uses a distributed data system. A copy of
                    the
                    user's data is kept in local device storage,
                    then asynchronously replicated in the cloud. The process generally works like this:
                </p>

                <ol>
                    <li>
                        Every new solve is created offline first.
                    </li>
                    <li>
                        The client then attempts to POST the new solve to the server. If successful, the API responds
                        with
                        the new solve object, and this is added to the local database.
                    </li>
                    <li>Network timeouts and failed connections throw the app into "UserOffline" state.
                        In this state, solves can be created locally, but not modified or deleted.
                    </li>
                    <li>While in "UserOffline" state, the device periodically tries to reconnect (polling)</li>
                    <li>Once connection is established, the device re-authenticates with the server. It pulls the latest
                        data down and pushes up any 'offline' solves.</li>
                </ol>

                <p>
                    For local storage, QC uses an Isar NoSQL database, which supports multiple platforms and is
                    written in
                    Rust. This approach comes nice features -- advanced querying, type safety, and the
                    ability to subscribe to streams of data changes.
                </p>

                <p>
                    One common problem with data replication is how to handle conflicting updates and deletes. Quantum
                    Cube works around this by following a simple rule: offline devices may create or modify
                    <em>offline</em> data,
                    but can never modify <em>online</em> data. This is suitable for our use-case, since cubers rarely
                    need
                    to
                    edit their solves after they are created.
                </p>

                <h3>Cube scrambles and solutions -- search algorithms in Dart</h3>
                <h4>The Challenge:</h4>
                <p>
                    A core feature of Quantum Cube is generating scramble instructions for the user to solve.
                    Scrambles tell the user how to mix up the cube before starting a solve. Scramble instructions are
                    presented in 'scramble notation', which may look something like this:
                <blockquote>
                    U2 L2 D2 U R U' L2 D U L' R' F R U' L2 F D' U2 L F'
                </blockquote>
                <span>For more info on scramble notation, <a
                        href="https://www.speedcube.us/blogs/notation-guides/3x3-rubiks-cube-notation">see this
                        in-depth explanation</a> </span>
                </p>
                <p>
                    If the scrambles are not random enough, users may complain that the puzzles are too easy, or don't
                    accurately simulate a competition. On the other hand, if the scramble is too random, it may
                    contain invalid or non-sensical moves.

                    For example, the sequence
                <blockquote>L R L' R2</blockquote> may be appear to be valid, but it results in the same state as
                simply doing: <blockquote>R'</blockquote>
                </p>

                <h4>The Solution:</h4>
                <p>
                    Because Dart is a relatively new language, it lacks the cubing-related libraries available in the
                    JavaScript ecosystem. For Quantum Cube Flutter, it was necessary to implement scramble generators
                    from scratch in Dart. Luckily, there are many excellent resources out there on how to model Rubik's
                    cubes,
                    <a href="https://observablehq.com/@onionhoney/how-to-model-a-rubiks-cube">
                        such as this one.
                    </a>
                </p>
                <p>In practice there are two approaches to generating scrambles.</p>
                <h5>1. A List of Random Moves</h5>
                <ol>
                    <li>
                        Generate a list of random numeric values with a fixed length. The length will depend on the
                        puzzle type.
                    </li>
                    <li>
                        Map each number to a move in the scramble notation. It may be useful to use a lookup table for
                        this.
                    </li>
                    <li>
                        Validate the moves in the sequence to prevent duplication, reversals, or orthoganal
                        moves (e.g., U D or B' F2)
                    </li>
                </ol>

                <p>
                    This approach is naive, but can work well for small, structured puzzles such as 'Clock' or
                    'Pyraminx'.
                </p>

                <h5>2. A Cube Solver Algorithm</h5>
                <ol>
                    <li>
                        Model the puzzle and the valid moves in a data structure. For example, a 2D array
                        representing the faces and stickers of a cube.
                    </li>
                    <li>
                        Generate a random starting state. It's not important what the scramble for
                        this state is, but it must be a valid state for the puzzle.
                    </li>
                    <li>
                        Use a depth-first search algorithm -- recursively testing sequences of moves until an optimal
                        solution is found.
                    </li>
                </ol>
                <p>
                    For more complex puzzles, such as the 3x3x3, the second approach is more suitable. It provides
                    consistent randomness, while guaranteeing a valid set of moves. However, the DFS
                    can quickly become time and memory constrained with complex puzzles. A common approach is to break
                    the
                    solution into "phases", where each phase solves a subset of the puzzle.
                    <a href="https://kociemba.org/math/imptwophase.htm">
                        Kociemba's 2-phase algorithm is a famous example.
                    </a>
                </p>
            </article>
        </section>
    </main>
</body>

<script src="/assets/main.js"></script>

</html>